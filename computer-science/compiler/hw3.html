<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">

<head>
    <!-- Book generated using mdBook -->
    <meta charset="UTF-8">
    <title>hw3 - something</title>


    <!-- Custom HTML head -->
    
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#ffffff" />

    <link rel="icon" href="../../favicon.svg">
    <link rel="shortcut icon" href="../../favicon.png">
    <link rel="stylesheet" href="../../css/variables.css">
    <link rel="stylesheet" href="../../css/general.css">
    <link rel="stylesheet" href="../../css/chrome.css">
    <link rel="stylesheet" href="../../css/print.css" media="print">

    <!-- Fonts -->
    <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
    <link rel="stylesheet" href="../../fonts/fonts.css">

    <!-- Highlight.js Stylesheets -->
    <link rel="stylesheet" href="../../highlight.css">
    <link rel="stylesheet" href="../../tomorrow-night.css">
    <link rel="stylesheet" href="../../ayu-highlight.css">
    <link rel="stylesheet" href="../../monokai.css">

    <!-- Custom theme stylesheets -->
    <link rel="stylesheet" href="../../theme/pagetoc.css">

    <!-- google anagles-->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-E4ZX8LPY4F"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-E4ZX8LPY4F');
        //ga('send', 'pageview');
    </script>
</head>

<body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch (e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch (e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../../math/index.html"><strong aria-hidden="true">1.</strong> math</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/calculus.html"><strong aria-hidden="true">1.1.</strong> calculus</a></li><li class="chapter-item "><a href="../../math/formal-language/formal-language.html"><strong aria-hidden="true">1.2.</strong> formal language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/formal-language/formal-language.html"><strong aria-hidden="true">1.2.1.</strong> formal language</a></li><li class="chapter-item "><a href="../../math/formal-language/hw1.html"><strong aria-hidden="true">1.2.2.</strong> hw1</a></li></ol></li><li class="chapter-item "><a href="../../math/linear-algebra.html"><strong aria-hidden="true">1.3.</strong> linear algebra</a></li><li class="chapter-item "><a href="../../math/math-modeling/math-modeling.html"><strong aria-hidden="true">1.4.</strong> math-modeling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/math-modeling/round-robin-tournament.html"><strong aria-hidden="true">1.4.1.</strong> round-robin-tournament</a></li></ol></li><li class="chapter-item "><a href="../../math/matrix-algebra/matrix-algebra.html"><strong aria-hidden="true">1.5.</strong> matrix algebra</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/matrix-algebra/matrix-algebra.html"><strong aria-hidden="true">1.5.1.</strong> matrix algebra</a></li><li class="chapter-item "><a href="../../math/matrix-algebra/Q2.html"><strong aria-hidden="true">1.5.2.</strong> Q2</a></li><li class="chapter-item "><a href="../../math/matrix-algebra/Q3.html"><strong aria-hidden="true">1.5.3.</strong> Q3</a></li></ol></li><li class="chapter-item "><a href="../../math/probability/hw2.html"><strong aria-hidden="true">1.6.</strong> probability</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/probability/hw2.html"><strong aria-hidden="true">1.6.1.</strong> hw2</a></li><li class="chapter-item "><a href="../../math/probability/hw3.html"><strong aria-hidden="true">1.6.2.</strong> hw3</a></li><li class="chapter-item "><a href="../../math/probability/hw4.html"><strong aria-hidden="true">1.6.3.</strong> hw4</a></li><li class="chapter-item "><a href="../../math/probability/hw5.html"><strong aria-hidden="true">1.6.4.</strong> hw5</a></li><li class="chapter-item "><a href="../../math/probability/hw6.html"><strong aria-hidden="true">1.6.5.</strong> hw6</a></li><li class="chapter-item "><a href="../../math/probability/hw7.html"><strong aria-hidden="true">1.6.6.</strong> hw7</a></li><li class="chapter-item "><a href="../../math/probability/hw8.html"><strong aria-hidden="true">1.6.7.</strong> hw8</a></li><li class="chapter-item "><a href="../../math/probability/hw9.html"><strong aria-hidden="true">1.6.8.</strong> hw9</a></li></ol></li><li class="chapter-item "><a href="../../math/signals-and-systems/signals-and-systems.html"><strong aria-hidden="true">1.7.</strong> signals and systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../math/signals-and-systems/signals-and-systems.html"><strong aria-hidden="true">1.7.1.</strong> signals processing</a></li><li class="chapter-item "><a href="../../math/signals-and-systems/mid.html"><strong aria-hidden="true">1.7.2.</strong> mid</a></li><li class="chapter-item "><a href="../../math/signals-and-systems/final.html"><strong aria-hidden="true">1.7.3.</strong> final</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../computer-science/index.html"><strong aria-hidden="true">2.</strong> computer science</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../computer-science/compiler/compiler.html"><strong aria-hidden="true">2.1.</strong> compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/compiler/compiler.html"><strong aria-hidden="true">2.1.1.</strong> compiler</a></li><li class="chapter-item "><a href="../../computer-science/compiler/hw0.html"><strong aria-hidden="true">2.1.2.</strong> hw0</a></li><li class="chapter-item "><a href="../../computer-science/compiler/hw1.html"><strong aria-hidden="true">2.1.3.</strong> hw1</a></li><li class="chapter-item "><a href="../../computer-science/compiler/hw2.html"><strong aria-hidden="true">2.1.4.</strong> hw2</a></li><li class="chapter-item expanded "><a href="../../computer-science/compiler/hw3.html" class="active"><strong aria-hidden="true">2.1.5.</strong> hw3</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/computer-graphics/computer-graphics.html"><strong aria-hidden="true">2.2.</strong> computer-graphics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/computer-graphics/deferred-rendering.html"><strong aria-hidden="true">2.2.1.</strong> deferred-rendering</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/computer-network/computer-network.html"><strong aria-hidden="true">2.3.</strong> computer networking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/computer-network/computer-network.html"><strong aria-hidden="true">2.3.1.</strong> computer networking</a></li><li class="chapter-item "><a href="../../computer-science/computer-network/hw1.html"><strong aria-hidden="true">2.3.2.</strong> hw1</a></li><li class="chapter-item "><a href="../../computer-science/computer-network/hw2.html"><strong aria-hidden="true">2.3.3.</strong> hw2</a></li><li class="chapter-item "><a href="../../computer-science/computer-network/hw4.html"><strong aria-hidden="true">2.3.4.</strong> hw4</a></li><li class="chapter-item "><a href="../../computer-science/computer-network/hw5.html"><strong aria-hidden="true">2.3.5.</strong> hw5</a></li><li class="chapter-item "><a href="../../computer-science/computer-network/hw6.html"><strong aria-hidden="true">2.3.6.</strong> hw6</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/CSG.html"><strong aria-hidden="true">2.4.</strong> CSG(Constructive Solid Geometry) mesh boolean</a></li><li class="chapter-item "><a href="../../computer-science/data-science/data-science.html"><strong aria-hidden="true">2.5.</strong> data science</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/data-science/data-science.html"><strong aria-hidden="true">2.5.1.</strong> data science</a></li><li class="chapter-item "><a href="../../computer-science/data-science/hw1.html"><strong aria-hidden="true">2.5.2.</strong> hw1</a></li><li class="chapter-item "><a href="../../computer-science/data-science/hw2.html"><strong aria-hidden="true">2.5.3.</strong> hw2</a></li><li class="chapter-item "><a href="../../computer-science/data-science/hw3.html"><strong aria-hidden="true">2.5.4.</strong> hw3</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/database-systems/database-systems.html"><strong aria-hidden="true">2.6.</strong> database systems</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/database-systems/database-systems.html"><strong aria-hidden="true">2.6.1.</strong> database systems</a></li><li class="chapter-item "><a href="../../computer-science/database-systems/hw1.html"><strong aria-hidden="true">2.6.2.</strong> hw1</a></li><li class="chapter-item "><a href="../../computer-science/database-systems/hw2.html"><strong aria-hidden="true">2.6.3.</strong> hw2</a></li><li class="chapter-item "><a href="../../computer-science/database-systems/hw3.html"><strong aria-hidden="true">2.6.4.</strong> hw3</a></li><li class="chapter-item "><a href="../../computer-science/database-systems/hw4.html"><strong aria-hidden="true">2.6.5.</strong> hw4</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/leetcode.html"><strong aria-hidden="true">2.7.</strong> leetcode</a></li><li class="chapter-item "><a href="../../computer-science/machine-learing/machine-learing.html"><strong aria-hidden="true">2.8.</strong> machine-learing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/machine-learing/auto-encoder.html"><strong aria-hidden="true">2.8.1.</strong> auto-encoder</a></li><li class="chapter-item "><a href="../../computer-science/machine-learing/reinforcement-learning.html"><strong aria-hidden="true">2.8.2.</strong> reinforcement-learning</a></li><li class="chapter-item "><a href="../../computer-science/machine-learing/transformer.html"><strong aria-hidden="true">2.8.3.</strong> transformer</a></li><li class="chapter-item "><a href="../../computer-science/machine-learing/gan.html"><strong aria-hidden="true">2.8.4.</strong> gan</a></li></ol></li><li class="chapter-item "><a href="../../computer-science/model-checking/model-checking.html"><strong aria-hidden="true">2.9.</strong> model-checking</a></li><li class="chapter-item "><a href="../../computer-science/nerf.html"><strong aria-hidden="true">2.10.</strong> nerf</a></li><li class="chapter-item "><a href="../../computer-science/operating-system/operating-system.html"><strong aria-hidden="true">2.11.</strong> operating system</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../computer-science/operating-system/operating-system.html"><strong aria-hidden="true">2.11.1.</strong> operating system</a></li><li class="chapter-item "><a href="../../computer-science/operating-system/hw1.html"><strong aria-hidden="true">2.11.2.</strong> hw1</a></li><li class="chapter-item "><a href="../../computer-science/operating-system/hw2.html"><strong aria-hidden="true">2.11.3.</strong> hw2</a></li><li class="chapter-item "><a href="../../computer-science/operating-system/hw3.html"><strong aria-hidden="true">2.11.4.</strong> hw3</a></li><li class="chapter-item "><a href="../../computer-science/operating-system/hw4.html"><strong aria-hidden="true">2.11.5.</strong> hw4</a></li></ol></li></ol></li><li class="chapter-item "><a href="../../tool/index.html"><strong aria-hidden="true">3.</strong> tool</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../../tool/BitTorrent.html"><strong aria-hidden="true">3.1.</strong> BitTorrent</a></li><li class="chapter-item "><a href="../../tool/docker.html"><strong aria-hidden="true">3.2.</strong> docker</a></li><li class="chapter-item "><a href="../../tool/ffmpeg.html"><strong aria-hidden="true">3.3.</strong> ffmpeg</a></li><li class="chapter-item "><a href="../../tool/git.html"><strong aria-hidden="true">3.4.</strong> git</a></li><li class="chapter-item "><a href="../../tool/graphviz.html"><strong aria-hidden="true">3.5.</strong> graphviz</a></li><li class="chapter-item "><a href="../../tool/shields.io.html"><strong aria-hidden="true">3.6.</strong> shields.io</a></li><li class="chapter-item "><a href="../../tool/shortcut.html"><strong aria-hidden="true">3.7.</strong> shortcut</a></li><li class="chapter-item "><a href="../../tool/vim.html"><strong aria-hidden="true">3.8.</strong> vim</a></li></ol></li><li class="chapter-item "><a href="../../concept/japanese.html"><strong aria-hidden="true">4.</strong> japanese</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents"
                            aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme"
                            aria-label="Change theme" aria-haspopup="true" aria-expanded="false"
                            aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="monokai">Monokai</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)"
                            aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S"
                            aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">something</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/x06lan/mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..."
                            aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function (link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="sidetoc">
                            <nav class="pagetoc"></nav>
                        </div>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="hw3"><a class="header" href="#hw3">hw3</a></h1>
<p><a href="../../assets/pdf/compiler_HW3.pdf">compiler HW3.pdf</a></p>
<h2 id="runsh"><a class="header" href="#runsh">run.sh</a></h2>
<pre><code class="language-bash">ocaml HW3.ml
dot -Tpdf autom2.dot &gt; autom.pdf &amp;&amp; firefox autom.pdf 
ocamlopt a.ml lexer.ml &amp;&amp; ./a.out
</code></pre>
<h2 id="hw3-1"><a class="header" href="#hw3-1">hw3</a></h2>
<pre><code class="language-haskell">
type ichar = char * int
type regexp =
| Epsilon
| Character of ichar
| Union of regexp * regexp
| Concat of regexp * regexp
| Star of regexp

(*
Exercise 1: Nullity of a regular expression
val null : regexp -&gt; bool
*)
let rec null a  = 
    match a with 
    | Epsilon -&gt; 
        true
    | Character (c,v) -&gt; 
        false
    | Union  (r1,r2) -&gt;
        null(r1) || null(r2)
    | Concat (r1,r2) -&gt;
        null(r1) &amp;&amp; null(r2)
    | Star  r1 -&gt; 
        true



let () =
    let a = Character ('a', 0) in

    assert (not (null a));
    assert (null (Star a));
    assert (null (Concat (Epsilon, Star Epsilon)));
    assert (null (Union (Epsilon, a)));
    assert (not (null (Concat (a, Star a))))

let () = print_endline &quot;🎉✅ Exercise 1: tests passed successfully!&quot;

(*
Exercise 2: The first and the last
*)
module Cset = Set.Make(struct type t = ichar let compare = Stdlib.compare end)

(*
val first : regexp -&gt; Cset.t
*)

let rec first r =
  match r with
  | Epsilon -&gt; Cset.empty  (* Epsilon has no characters *)
  | Character c -&gt; Cset.singleton c  (* The character itself is the first *)
  | Union (r1, r2) -&gt; Cset.union (first r1) (first r2)
  | Concat (r1, r2) -&gt; if null r1 then Cset.union (first r1) (first r2)
                       else first r1
  | Star r1 -&gt; first r1  (* Star can repeat, but first is just the first of the repeated expression *)


(*
val last : regexp -&gt; Cset.t
*)

let rec last r =
  match r with
  | Epsilon -&gt; Cset.empty  (* Epsilon has no characters *)
  | Character c -&gt; Cset.singleton c  (* The character itself is the first *)
  | Union (r1, r2) -&gt; Cset.union (last r1) (last r2)
  | Concat (r1, r2) -&gt; if null r2 then Cset.union (last r1) (last r2)
                       else last r2
  | Star r1 -&gt; last  r1  (* Star can repeat, but first is just the first of the repeated expression *)



let () =
    let ca = ('a', 0) and cb = ('b', 0) in
    let a = Character ca and b = Character cb in
    let ab = Concat (a, b) in
    let eq = Cset.equal in
    assert (eq (first a) (Cset.singleton ca));
    assert (eq (first ab) (Cset.singleton ca));
    assert (eq (first (Star ab)) (Cset.singleton ca));
    assert (eq (last b) (Cset.singleton cb));
    assert (eq (last ab) (Cset.singleton cb));
    assert (Cset.cardinal (first (Union (a, b))) = 2);
    assert (Cset.cardinal (first (Concat (Star a, b))) = 2);
    assert (Cset.cardinal (last (Concat (a, Star b))) = 2)


let () = print_endline &quot;🎉✅ Exercise 2: tests passed successfully!&quot;
(*
Exercise 3: The follow
*)

let print x = 
    match x with 
    |  (c,v)  -&gt; print_endline (Char.escaped c ^ &quot; &quot; ^ string_of_int v)
let print_set pre x = 
    (* Cset.iter (fun (c,v) -&gt; print_string (Char.escaped c ^ &quot; &quot; ^ string_of_int v ^ &quot;\n&quot;)) x *)
    print_endline pre;
    Cset.iter (fun (c,v) -&gt; print_string ( pre ^ &quot; &quot; ^ Char.escaped c ^ &quot; &quot; ^ string_of_int v ^ &quot;\n&quot;)) x
    (* let ()=print_string  &quot;\n&quot; *)

(* val follow : ichar -&gt; regexp -&gt; Cset.t *)
let rec follow ic r =
    match r with
    | Epsilon -&gt; 
        Cset.empty  (* Epsilon has no characters *)
    | Character (c,v) -&gt; 
        Cset.empty

    | Union (r1, r2) -&gt; 
        Cset.union (follow ic r1) (follow ic r2)
    | Concat (r1, r2) -&gt; 
        let x=  last(r1) in
        if Cset.mem ic x then
            Cset.union (Cset.union (follow ic r1 ) (follow ic r2 )) (first r2 )
        else
            Cset.union (follow ic r1 ) (follow ic r2 )
    | Star r1 -&gt; 
        let x=  last(r1) in
        if Cset.mem ic x then
            Cset.union (follow ic r1 ) (first r1 )
        else
            follow ic r1
        


let () =
    let ca = ('a', 0) and cb = ('b', 0) in
    let a = Character ca and b = Character cb in
    let ab = Concat (a, b) in
    assert (Cset.equal (follow ca ab) (Cset.singleton cb));
    assert (Cset.is_empty (follow cb ab));
    let r = Star (Union (a, b)) in
    assert (Cset.cardinal (follow ca r) = 2);
    assert (Cset.cardinal (follow cb r) = 2);
    let r2 = Star (Concat (a, Star b)) in
    assert (Cset.cardinal (follow cb r2) = 2);
    let r3 = Concat (Star a, b) in
    assert (Cset.cardinal (follow ca r3) = 2)

let () = print_endline &quot;🎉✅ Exercise 3: tests passed successfully!&quot;

(* Exercise 4: Construction of the automaton *)

type state = Cset.t (* a state is a set of characters *)
module Cmap = Map.Make(Char) (* dictionary whose keys are characters *)
module Smap = Map.Make(Cset) (* dictionary whose keys are states *)
type autom = {
    start : state;
    trans : state Cmap.t Smap.t (* state dictionary -&gt; (character dictionary -&gt;state) *)
}
(* cmap[c]=state *)
(* smap[state]=cmap *)
let map1= Cmap.add 'a' Cset.empty Cmap.empty
let map2= Smap.add Cset.empty map1 Smap.empty




(* val next_state : regexp -&gt; Cset.t -&gt; char -&gt; Cset.t *)
(* val next_state : regexp -&gt; state -&gt; char -&gt; state *)
let rec next_state r s c =
    (* Combine the first sets of states reachable from s via character c
       according to the transitions defined by r. *)
    
    let reachable_states = 
        Cset.fold (fun (ch, v) acc -&gt; 
            (* print_endline (Char.escaped ch ^ &quot; &quot; ^ string_of_int v ^ &quot; &quot; ^ Char.escaped c); *)
            if ch = c then 
                (* let ()= print_set &quot;follow&quot; (follow (ch, v) r) in *)
                (* let f=(follow (ch, v) r) in *)
                Cset.union acc (follow (ch, v) r)
            else 
                acc
        ) s Cset.empty
    in
    reachable_states
let eof = ('#', -1)

(* val make_dfa : regexp -&gt; autom *)
let make_dfa (r:regexp) =
    let r = Concat (r,  Character eof) in
    (* let k = Epsilon in *)
    (* let r = Concat (r,k  ) in *)
    let trans = ref Smap.empty in

    let rec transitions q =
        
        let find_all_next_state = 
            Cset.fold (fun (c, v) map -&gt;
                let q' = next_state r q c in
                Cmap.add c q' map
            ) q Cmap.empty
        in
        trans := Smap.add q find_all_next_state !trans;

        (* Process the newly added states in transitions map *)
        Cmap.iter (fun c q' -&gt; 
            (* the state that not find yet *)
            if not (Smap.mem q' !trans) then
                transitions q'
        )  find_all_next_state;
    in

    let q0 = first r in
    
    transitions q0;
    { start = q0; trans = !trans }
    

let fprint_state fmt q =
    Cset.iter (fun (c,i) -&gt;
    if c = '#' then Format.fprintf fmt &quot;# &quot; else Format.fprintf fmt &quot;%c%i &quot; c i) q
let fprint_transition fmt q c q' =
    Format.fprintf fmt &quot;\&quot;%a\&quot; -&gt; \&quot;%a\&quot; [label=\&quot;%c\&quot;];@\n&quot;
    fprint_state q
    fprint_state q'
    c
let fprint_autom fmt a =
    Format.fprintf fmt &quot;digraph A {@\n&quot;;
    Format.fprintf fmt &quot; @[\&quot;%a\&quot; [ shape = \&quot;rect\&quot;];@\n&quot; fprint_state a.start;
    Smap.iter
        (fun q t -&gt; Cmap.iter (fun c q' -&gt; fprint_transition fmt q c q') t)
    a.trans;
    Format.fprintf fmt &quot;@]@\n}@.&quot;
let save_autom file a =
    let ch = open_out file in
    Format.fprintf (Format.formatter_of_out_channel ch) &quot;%a&quot; fprint_autom a;
    close_out ch

let () = print_endline &quot;🎉✅ Exercise 4: tests passed successfully!&quot;

(* Exercise 5: Word recognition *)

(* val recognize : autom -&gt; string -&gt; bool *)
let recognize (a:autom) (s:string) =
    (* let str_with_eof = s ^ &quot;#&quot; in *)
    let str_with_eof = s  in
    let final_state,accpet = String.fold_left (fun (q,accpet) c -&gt;
        if Cset.is_empty q then
            (* accpet or out of trans *)
            (q,accpet)
        else
            let cmap = Smap.find q a.trans in
            if Cmap.mem c cmap  then
                let q' = Cmap.find c cmap in
                (* let () = print_endline (Char.escaped c) in
                let () = print_set &quot;final&quot; q' in
                let _ =print_endline (string_of_bool( Cset.is_empty q' ))in *)
                (q', Cset.mem eof q')
            else
                (*out of trans *)
                (Cset.empty,false)

    ) (a.start,Cset.mem eof a.start) str_with_eof in
    accpet




(* (a|b)*a(a|b) *)
let r = Concat (Star (Union (Character ('a', 1), Character ('b', 1))),
    Concat (Character ('a', 2),
    Union (Character ('a', 3), Character ('b', 2))))


let a = make_dfa r
let () = save_autom &quot;autom.dot&quot; a

(* positive test *)
let () = assert (recognize a &quot;aa&quot;)
let () = assert (recognize a &quot;ab&quot;)
let () = assert (recognize a &quot;abababaab&quot;)
let () = assert (recognize a &quot;babababab&quot;)
let () = assert (recognize a (String.make 1000 'b' ^ &quot;ab&quot;))

(* neg test *)
let () = assert (not (recognize a &quot;&quot;))
let () = assert (not (recognize a &quot;a&quot;))
let () = assert (not (recognize a &quot;b&quot;))
let () = assert (not (recognize a &quot;ba&quot;))
let () = assert (not (recognize a &quot;aba&quot;))
let () = assert (not (recognize a &quot;abababaaba&quot;))



let r = Star (Union (Star (Character ('a', 1)),
    Concat (Character ('b', 1),
    Concat (Star (Character ('a',2)),
    Character ('b', 2)))))
let a = make_dfa r
let () = save_autom &quot;autom2.dot&quot; a

let () = assert (recognize a &quot;&quot;)
let () = assert (recognize a &quot;bb&quot;)
let () = assert (recognize a &quot;aaa&quot;)
let () = assert (recognize a &quot;aaabbaaababaaa&quot;)
let () = assert (recognize a &quot;bbbbbbbbbbbbbb&quot;)
let () = assert (recognize a &quot;bbbbabbbbabbbabbb&quot;)

let () = assert (not (recognize a &quot;b&quot;))
let () = assert (not (recognize a &quot;ba&quot;))
let () = assert (not (recognize a &quot;ab&quot;))
let () = assert (not (recognize a &quot;aaabbaaaaabaaa&quot;))
let () = assert (not (recognize a &quot;bbbbbbbbbbbbb&quot;))
let () = assert (not (recognize a &quot;bbbbabbbbabbbabbbb&quot;))

let () = print_endline &quot;🎉✅ Exercise 5: tests passed successfully!&quot;

(* Exercise 6: Generating a lexical analyzer *)


type buffer = { text: string; mutable current: int; mutable last: int }
let next_char b =
    if b.current = String.length b.text then raise End_of_file;
    let c = b.text.[b.current] in
    b.current &lt;- b.current + 1;
    c

type gen_state={ 
    id: int ;
    trans:state Cmap.t Smap.t;
}

(* val generate: string -&gt; autom -&gt; unit *)
let generate (filename: string) (a: autom) =
    let channel = open_out filename in
    try
        let state_id = ref Smap.empty in
        let count = ref 0 in
        
        (* Write formatted content to the file *)
        Printf.fprintf channel &quot;%s&quot; &quot;type buffer = { text: string; mutable current: int; mutable last: int }\n&quot;;
        Printf.fprintf channel &quot;%s&quot; &quot;let next_char b =
    if b.current = String.length b.text then raise End_of_file;
    let c = b.text.[b.current] in
    b.current &lt;- b.current + 1;
    c\n&quot;;

        let update_state_id (q : state) =
            if not (Smap.mem q !state_id) then (
                state_id := Smap.add q !count !state_id;
                count := !count + 1;
            );
            Smap.find q !state_id
        in
        let gen_state = Smap.fold (fun k v s -&gt; 
            let i=update_state_id k in
            (* first state *)
            let prefix_string = Format.asprintf (if i = 0 then &quot;let rec state%i b =\n&quot; else &quot;and state%i b =\n&quot;) i in

            (* accept state *)
            let accept = Cset.mem eof k in
            (* let prefix_string =if accept then prefix_string ^ &quot;  print_endline ((string_of_int b.last)^(string_of_int b.current));\n&quot; else prefix_string in *)
        

            if accept then
                let prefix_string =if accept then prefix_string ^ &quot;  b.last &lt;- b.current;\n&quot; else prefix_string in
            
                let s'=s^(prefix_string)^&quot;\n&quot;in
                s'
            else

                let prefix_string = prefix_string ^ &quot;  let c = next_char b in\n&quot; in
                let prefix_string = prefix_string ^ &quot;  match c with \n&quot; in

                let match_string = Cmap.fold (fun c q s' -&gt; 
                        
                    let q_id = update_state_id q in
                        let s'' = Format.asprintf &quot;  | '%c' -&gt; state%i b\n&quot; c q_id in
                        s' ^ s''
                ) v &quot;&quot; in
                let match_string = match_string ^ &quot;  | _ -&gt; raise (Failure \&quot;undefine key in state\&quot;)\n&quot; in

                let state_string=prefix_string ^ match_string in
                let s'=s^(state_string)^&quot;\n&quot;in
                s'

        ) a.trans &quot;&quot; in
        let start_string =  Format.asprintf &quot;let start = state%i\n&quot; (Smap.find a.start !state_id)in
        let gen_state = gen_state ^ start_string in

        Printf.fprintf channel &quot;%s&quot; gen_state;

        close_out channel
    with e -&gt;
        (* Ensure the file is closed if an error occurs *)
        close_out_noerr channel;
        raise e
    





(* a*b *)
let r3 = Concat (
        Star (Character ('a', 1)),
        Character ('b', 1)
    )
let a = make_dfa r3
let () = save_autom &quot;autom2.dot&quot; a
let () = generate &quot;a.ml&quot; a

let () = print_endline &quot;🎉✅ Exercise 6: tests passed successfully!&quot;

</code></pre>
<h2 id="lexerml"><a class="header" href="#lexerml">lexer.ml</a></h2>
<pre><code class="language-haskell">(* type buffer = { text: string; mutable current: int; mutable last: int } *)
type buffer = A.buffer
let () =
  let str = &quot;abbaaab&quot; in
  (* let (b: ref A.buffer) = ref { text = str; current = 0; last = -1 } in *)
  let (b: A.buffer) = { text = str; current = 0; last = -1 } in
  let flag = ref true in
  let start = A.start in

  while !flag do
    try 
      let last = if b.last = -1 then 0 else b.last in
      let () = start b in
      (* print_endline ( &quot;last: &quot;^(string_of_int b.last) ^&quot; current: &quot;^(string_of_int b.current)); *)
       if b.last != -1 then 
        (* print_endline ( (string_of_int last) ^&quot; &quot;^(string_of_int b.last)); *)
          let ac_string=String.sub b.text (last) (b.last-last) in
          print_endline (&quot;---&gt; &quot;^ac_string)
        ;

    with e -&gt;
      print_endline (Printexc.to_string e);
      match Printexc.to_string e with
      | &quot;Failure \&quot;undefine key in state\&quot;&quot; -&gt; flag := false
      | &quot;End_of_file&quot; -&gt; flag := false
      | _ -&gt; ()
  done
</code></pre>

                        <!-- github commet -->
                        <dir id="giscus"></dir>
                        <script>
                            var localAddrs = ["localhost", "127.0.0.1", ""];

                            if (localAddrs.indexOf(document.location.hostname) === -1) {
                                var giscusScript = document.createElement('script');
                                giscusScript.src = "https://giscus.app/client.js";
                                giscusScript.setAttribute('data-repo', 'x06lan/mdbook');
                                giscusScript.setAttribute('data-repo-id', 'R_kgDOJxZ6mQ');
                                giscusScript.setAttribute('data-category-id', 'DIC_kwDOJxZ6mc4CXeJ6');
                                giscusScript.setAttribute('data-mapping', 'pathname');
                                giscusScript.setAttribute('data-strict', '0');
                                giscusScript.setAttribute('data-reactions-enabled', '1');
                                giscusScript.setAttribute('data-emit-metadata', '0');
                                giscusScript.setAttribute('data-input-position', 'bottom');
                                giscusScript.setAttribute('data-theme', 'preferred_color_scheme');
                                giscusScript.setAttribute('data-lang', 'zh-TW');
                                giscusScript.setAttribute('crossorigin', 'anonymous');
                                giscusScript.async = true;
                                let giscusDiv = document.getElementById('giscus');
                                giscusDiv.appendChild(giscusScript);
                            }
                        </script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/pagetoc.js"></script>
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
</body>

</html>
